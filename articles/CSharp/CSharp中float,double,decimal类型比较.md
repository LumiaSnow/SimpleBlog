# C#中float, double, decimal类型比较

January 29, 2020 by Meepo, C#

---

## 基本定义

| 类型 | 定义 | 大小 | 指数范围 | 精度范围 | 效率 |
| ------ | ------ | ------ | ------ | ------ | ------ |
| float | 单精度浮点型 | 4 bytes | -127~+128 (基数2) | 2^23 | 高 |
| double | 双精度浮点型 | 8 bytes | -1023~+1024 (基数2) | 2^52 | 中 |
| decimal | 10进制浮点型 | 16 bytes | -127~+128 (基数10) | 2^96 | 低(double的10倍) |

## 什么是浮点型

在计算机中，表示小数使用“科学计数法”，即：

10进制:
123 = 1.23 * 10^2
0.0123 = 1.23 * 10^-2

而计算机使用2进制，所以：
100101 = 1.00101 * 2^5
0.011 = 1.1 * 2^-2

所以，浮点型在存储时，实数（100101）和指数（2^5）是分开存储的。

## 存储结构

基础：
1 byte = 8 bits

### float(4 bytes = 32 bits)

1bit（符号位）: 0正、1负
8bits（指数位）: 基数2
23bits（实数位）

### double(8 bytes = 64 bits)

1bit（符号位）: 0正、1负
11bits（指数位）: 基数2
52bits（实数位）

### decimal(16 bytes = 128 bits)

1bit（符号位）: 0正、1负
8bits（指数位）: 基数10
96bits（实数位）
23bits : 闲置，默认0

具体位置（index）：
0~15: 闲置0
16~23: 指数位
24~30: 闲置0
31: 符号位
32~127: 实数位

## 精度丢失问题

三者的精度范围不同，即表示可以精确到第几位有效数字，实质上是“存储实数部分的大小限制”。

如：float，精度为2^23 = 8388608

```C#
float f = 83886081f;  //实际f的值为83886080。
```

所以，对float、double、decimal来说，可表示的数值范围是很大的，但是超过精度范围后将无法精确表示。

## decimal的存在意义

float和double的基数都是2，所以只有基于2的数值才能够精确表示。
如：十进制的0.1使用2进制表示是一个无限循环小数。
原因是2的因数只有1和2，无法除尽5。

decimal的基数是10，10的因数有1，2，5，10，所以在表示数时比2进制更加准确。
同理10进制也无法表示1/3，1/7。

结论：
float和double不适合金融计算；
decimal更加适合金融计算。

注意：
在使用时float、double、decimal都存在舍入误差，即当除不尽时decimal会四舍五入，double会直接舍去。
所以：

```C#
decimal m = 1M / 6M;
decimal sum_m = m + m + m + m + m + m; //sum_m > 1M

double d = 1.0 / 6.0;
double sum_d = d + d + d + d + d + d; // sum_d < 1.0
```
